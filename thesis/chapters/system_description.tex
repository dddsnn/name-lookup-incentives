\chapter{System Description}
\label{chap:system_description}
\section{Assumptions and Prerequisites}
The system described in this chapter assumes that, for any pair of peers, there
is a reliable way for them to communicate at all times. In practice, this means
that each peer is able to establish and maintain a TCP connection with any other
peer. Messages may be delayed e.g. due to congestion, but must arrive
eventually. Issues arising from e.g. NAT that would make it impossible to
contact a peer directly, but also complete link failures that cause connections
to time out are considered out of scope.

While network delays can be dealt with, jitter should be low enough that future
delays can be predicted from past ones with reasonable accuracy.

Peers are assumed to have clocks, all of which are synchronized. Minor
variations are tolerable, though (typical accuracy of NTP is definitely enough).

Access to the \ac{DHT} is assumed to be equally distributed. This includes
firstly that the records are equally popular, i.e. each of them has the same
likelihood of being queried for. Secondly, all peers send the same volume of
queries. Sections~\ref{sec:desc_load_balancing}
and~\ref{sec:desc_credit_only_vs_credit_debit} discuss the consequences of these
assumptions not holding.

\subsection{Types of Peers}
\subsubsection{Selfish}
Selfish peers are the central type of peer this thesis focuses on, and the one
discussions are about unless otherwise indicated. They are lazy and only willing
to expend resources (network bandwidth, CPU time, memory) for their own benefit.
They only want to use them in order to be very likely in a position to receive
service quickly at all times. There is no explicit valuation determining what
"very likely" means to a peer. Rather, the reputation buffer described in
Section~\ref{sec:impl_coop_defect_behavior} acts as a proxy for it, determining
the reliably a peer receives good service.

When they don't see a benefit for themselves in taking a particular action they
won't do it, even if the protocol requires them to. Finding incentives for this
type of peer is a central part of this thesis, and achieved by threatening to
lower the quality of service. Section~\ref{sec:desc_rationale} goes into more
detail on the motivation of selfish peers.

\subsubsection{Generous}
\label{sec:desc_generous_peers}
Generous peers are in a way the opposite of selfish peers. They don't care about
their own benefit and strive to make others' lives easier, or at least they
behave in such a way. This can actually become a problem, since it reduces the
incentive for other peers to do work, thus counteracting the goal of providing
many peers to interact with. The system has to take measures against this kind
of behavior. Section~\ref{sec:desc_rep_system} goes into more detail.

Generous peers may actually be malicious, trying to attract a lot of traffic in
order to build profiles. This is briefly discussed in
Section~\ref{sec:desc_attacks_generous}, but otherwise out of the scope of this
thesis.

\subsubsection{Contented}
\label{sec:desc_contented_peers}
Contented peers don't care about the quality of service they receive and thus
can't be incentivized via it. These could e.g. be running on slow devices
without direct user interaction. If they appear in large numbers, they may cause
problems. Section~\ref{sec:rep_avail_selection_rep_sorted_contented} discusses
one such problem, but other than that, this type of peers is considered out of
scope.

\subsubsection{Colluding/Sybils}
Colluding peers are multiple selfish peers working together in order to do less
work while enjoying the same level of service. Sybils (peers performing a Sybil
attack) are single peers acting under multiple identities trying to achieve the
same thing.

These are out of scope of the implementation, but some ideas are presented in
Section~\ref{sec:desc_collusion_sybil_attacks} on how they may be dealt with.


\subsubsection{Malicious}
Malicious peers are motivated by causing harm to others or by disrupting the
entire system. They are willing to invest resources towards that goal without
the need for further incentives. One possible motivation is vengeance, peers
seeking to cause harm to particular peers who have wronged them. These are also
beyond the scope of this thesis.

\section{Organization}
\subsection{Overview}
The underlying \ac{DHT} for the system is one in the style of Kademlia or
P-Grid, briefly described in Section~\ref{sec:background_dhts}. Every peer has a
unique \emph{ID} that he chooses himself, and every \emph{record} in the
\ac{DHT} has a unique ID of the same length. In fact, each peer may store
exactly one record under its own ID, containing reachability information. As
mentioned previously, this constraint was added for simplicity. Under these
circumstances, querying for a record stored in the \ac{DHT} is done in order to
learn how to contact a peer. For this reason, the phrase "querying for a peer
(with some ID)" is frequently used in this thesis to mean querying for a record
in the \ac{DHT} with that peer's ID.

These IDs are bit strings of fixed length and routing takes place along a binary
tree formed by them. It may be possible to adapt the system to work with
\acp{DHT} using a different routing scheme, such as Chord. See
Section~\ref{sec:desc_querying} for details on how querying is handled in the
\ac{DHT} used by the system.

Every peer stores a number of records of the \ac{DHT}, he is \emph{responsible}
for these records. A number of other peers is also responsible for these same
records, and the peer stays in contact with them in a \emph{sync group}. In
these groups, peers synchronize their information about stored records, like the
creation of a new one, or the update of an existing one. See
Section~\ref{sec:desc_sync_groups} for details on sync groups.

The system implements a reputation system in which peers have a
\emph{reputation} that is tracked within \emph{query groups}. A peer has a
separate non-negative, real-valued reputation value in each such group that he
is a member of. This value is initialized to 0 upon entering the group. The
other members of these groups are the peer's \emph{query peers}, and every one
of them knows the current reputation of each of the other query peers. They are
the ones to whom the peer forwards queries he can't answer himself directly. The
way query groups are created, how they are managed, and what dynamics arise from
this is not examined in this thesis, but there proposals and more details on
query groups in Section~\ref{sec:desc_query_groups}.

A peer receives a \emph{reward}, i.e. an increase of his reputation in a query
group if he performs a \emph{cooperative action} towards a peer in that group.
Conversely, he receives a \emph{penalty}, i.e. a decrease of his reputation in a
query group, if he performs a \emph{defecting action} towards a peer in that
group. However, reputation is non-negative, and so penalties have no effect if
the peer has 0 reputation. The terms \emph{cooperative} and \emph{defecting} are
chosen following the terms from game theory. An example (in fact the only
example relevant for the implementation considered in this thesis) of a
cooperative action is responding to a query with the correct answer within the
time frame demanded by the system's \emph{rules} (the set of parameters).
Examples of a defecting action are not responding to a query, responding with an
answer that states that the query could not be resolved, or responding too early
or too late. See Section~\ref{sec:desc_rep_management} for details on how
reputation is tracked in query groups.

The reputation peers earn is used to determine the quality of service they
receive. Peers responding to queries are mandated to apply a \emph{penalty
delay} (not to be confused with a \emph{penalty}, described above) appropriate
to the reputation of the querying peer. This includes deliberately delaying the
answer. The rules of the system define a \emph{penalty threshold reputation} (or
just \emph{penalty threshold}), which is the amount of reputation a peer must be
at or above in order to be entitled to receive responses without penalty delay
from query peers in the corresponding query group. If the querying peer's
reputation is below the penalty threshold, the penalty delay in seconds is
chosen inversely proportional to the peer's reputation: the more reputation, the
lower the delay.

Reputation is credit-only, i.e. once a peer has passed the penalty threshold he
may send as many queries as he likes and is entitled to delay-free service, he
doesn't have to "pay" with having his reputation reduced for a query.

Above the penalty threshold, \emph{reputation attenuation} makes it more
difficult for peers to gain further reputation. A distinction is made between
\emph{raw reputation} and \emph{effective reputation}. The latter is calculated
from the former by attenuating it. See Section~\ref{sec:attenuation} for the
rationale behind this and a more detailed description.

During operation, pairs of peers exchange messages without other peers knowing
their content or even being aware communication is taking place at all.
Disagreements may occur between peers about whether the other's behavior was
within the rules of the system. For example, a querying peer may claim that the
responding peer took too long to respond and should receive a penalty, while the
responding peer insists he responded in time and should receive a reward.
Neither of the peers is able to prove his claim. A distributed \emph{complaint
system} needs to be in place that can make rulings in these situations. Such a
system is not part of the implementation in this thesis, and there may be very
complex dynamics arising from such a system that are not foreseeable without a
simulation. However, a proposal is presented in
Section~\ref{sec:desc_complaints}.

At many points, the system relies on messages being authenticated. It is assumed
that all messages exchanged between peers are signed to prevent one peer
impersonating another. Since peers only store one record in the \ac{DHT} with
their own ID as key, these records are also signed. Peer IDs are chosen to be
fingerprints of the peer's public key, so that there doesn't have to be a
mapping from peer ID to public key. The full public key can be distributed once
a peer learns about another peer for the first time, e.g. as supplementary
information in the peer's record in the DHT.

\subsection{Sync Groups}
\label{sec:desc_sync_groups}
Every peer has a \emph{routing prefix}, which is a prefix of the peer's ID. The
length of the routing prefix is fixed in the rules of the system and the same
for all peers. A peer is responsible for all records whose ID starts with his
routing prefix. In short, he is responsible for the routing prefix. He maintains
contact with other peers who have the same routing prefix; these peers make up
his sync group and are called his \emph{sync peers}.

Sync peers keep each other apprised of changes to their record\footnote{As a
reminder, in this simplified version, peers store exactly one record in the
\ac{DHT}, where the key is their own ID.}. When it needs to be updated, they
broadcast the new record to all their sync peers, who then update their local
copy.

Since every peer stores exactly one record in the \ac{DHT} under his own ID,
creating a new record to be maintained in the sync group is equivalent to
joining the group. To do this, the peer needs to know at least one other peer
who is already a member of the sync group and gives him the contact information
of all other sync peers. Then he broadcasts his new record to all the members.

Conversely, deleting a record is equivalent to leaving the group. In this case,
the peer simply broadcasts a notification to his sync peers.

Sync groups are relevant to replication within the \ac{DHT}. Every peer's record
is replicated as many times as there are peers in the sync group. The mean
replication factor in the \ac{DHT} is $\frac{n}{2^l}$, where $n$ is the total
number of peers participating in the \ac{DHT}, and $l$ is the length of the
routing prefix in bits.

No fixed replication factor can be guaranteed in this way, since the routing
prefixes are determined by the peer IDs, which peers choose themselves. It may
happen that one routing prefix is chosen by many fewer peers than another,
giving their records much lower replication. To address this, load balancing is
possible, see Section~\ref{sec:desc_load_balancing}.

\subsection{Querying}
\label{sec:desc_querying}
If a peer wants to get hold of a record (the key of which is called the
\emph{target ID}), he must send a query to another peer, the recipient. He
queries a peer known to him who is \emph{closer to} the target ID. This is the
case if the overlap of the recipient's routing prefix with the target ID is
greater than the overlap of the peer's own routing prefix with the target ID.
The overlap $o(a, b)$ of a bit string $a_i, i \in \{1, \ldots, n\}$ of length
$n$ and a bit string $b_j, j \in \{1, \ldots, m\}$ of length $m$ is defined as
\[o(a, b) = \max_{k \in \{0, \ldots, \min(n, m)\}} a_i = b_i \forall i \in \{1,
\ldots, k\}.\]

Note that, in case the peer's routing prefix overlaps entirely with the target
ID, i.e. it is also a prefix of the target ID, the peer himself is responsible
for the record and should know it and not need to query anyone.

In case the recipient doesn't know the record himself, further querying is
necessary. There are multiple possibilities for handling this. The simplest of
them is a recursive query, analogous to recursive DNS queries, in which the
recipient of the initial query does all the work. He selects a peer closer to
the target ID and sends him a query. This peer again may need to query another
peer. But this can only be the case a finite number of times, since the next
peer queried must always be closer to the target ID, so eventually one is
reached who is responsible for it. Once a response arrives at one of the peers
in this chain of queries, it is used to respond to the peer who queried him.
There are alternatives to this procedure discussed in
Section~\ref{sec:desc_recursive_vs_iterative}.

In this chain of queries, one of them may fail or time out. The peer should then
retry the query with a different suitable peer. If he has exhausted all the
possibilities, the query has failed. If the peer was querying on behalf of
another, he should send a \emph{fail response}, indicating he is unable to
resolve the query.

Peers may elect to send multiple queries at once instead of waiting for one to
fail first. This reduces the risk of letting the querying peer wait
unnecessarily, especially if a timeout has to be waited out.

There may not exist a record under the target ID. In that case, the recipient of
the query should respond with a message that indicates this. A peer who isn't
responsible for the routing prefix of the target ID isn't guaranteed to be aware
of changes to its records though. For example, a new one may recently have been
added. Only peers in the sync group responsible for that routing prefix are
synchronizing information about relevant records. The sync group therefore is an
\emph{authority} for the routing prefix, and so are its sync peers. Therefore,
the responding peer must include a signature from an authoritative sync peer in
the message that indicates no record exists for the target ID.

Instead of querying for a complete ID, the target ID can be a prefix of an ID of
arbitrary length (it can even be empty). A correct response to such a query is
any record whose ID starts with the target ID. This is useful for learning about
peers to complete one's subprefix coverage (see
Section~\ref{sec:desc_query_groups}). A response stating that no record with the
target ID exists in this context means that no record exists in the entire
\ac{DHT} whose ID starts with the target ID.

Additionally, when querying for a prefix, a querying peer may specify a number
of IDs or prefixes of IDs to exclude. The response must not match any of the
excluded IDs or prefixes. This is useful for peers looking for peers with
certain prefixes: They can list the IDs of peers they already know in order to
learn about peers they don't yet. If they then receive a response stating that
no record with the target ID exists, it means that they already know all peers
matching the target ID.

\subsection{Query Groups}
\label{sec:desc_query_groups}
Query groups are the second kind of group employed by the system. Every peer may
be in multiple query groups, other members are called his \emph{query peers}.
Query peers are the pool of potential recipients of queries.

Query groups are the unit within which reputation is tracked. Reputation is
synchronized within a query group, so that every peer is aware of each of his
query peer's reputations. In order for this to remain scalable, query groups
should be kept reasonably small. Section~\ref{sec:desc_rep_management} contains
details on how the reputation record is kept up to date.

\subsubsection{Rewards, Penalties, and Penalty Delays}
The reason peers should only send queries to query peers is that their
reputation determines the quality of service they're entitled to receive. When
receiving a query, peers are required to consider the reputation of the querying
peer and apply a penalty delay, if applicable, i.e. to purposefully delay the
response. Failing to do so is itself a defecting action and incurs a penalty.
The appropriate penalty delay is $\max(0, t - r)$, where $t$ is the penalty
threshold reputation and $r$ is the peer's reputation.

The penalty thresholg is part of the rules of the system, and thus known to
everyone, and $r$ is known to all query peers. This means the sender of the
query knows what penalty delay is appropriate for his query. If a response has
not arrived $d + l$ after the query has been sent, where $l$ is another
parameter to account for network latency, the response is late and the querying
peer must apply a penalty for a timeout. If the response arrives after less than
$d$ time has passed, the response is early and the querying peer must apply a
penalty for an early query.

Otherwise, the response has arrived within the correct time frame. In that case,
the querying peer must either apply a penalty for a failed response if the
response indicates that the recipient is unable to answer the query, or apply a
reward for a successful query if the response appears to contain the correct
information.

Furthermore, the querying peer may, through one or more additional queries, find
that the response was incorrect. This can be either because it was outdated, or
because it falsely claimed that no record existed for the target ID, when in
fact it did. In that case, the querying peer must apply a penalty for an
incorrect response.\footnote{To detect whether a record is outdated, they
contain a timestamp giving the last time they were changed. There should be some
leeway given, though. No penalty should be applied if the record has only just
been updated.}

\subsubsection{Subprefix Coverage}
Section~\ref{sec:desc_querying} described the process of sending a query and
stated that a peer wishing to send a query must send it to a recipient who is
closer to the target ID of the query. This requires the peer to know such a
recipient for every possible target ID. This is the case if the peer has
complete \emph{subprefix coverage}.

A bit string is a peer's \emph{subprefix} iff it is no longer than the peer's
routing prefix, all of it but the final bit is a prefix of the peer's routing
prefix, but the whole thing is not.

Formally, a bit string $s_i, i \in \{1, \ldots, n\}$ of length $n$ is a
subprefix of a peer with routing prefix $p_j, j \in \{1, \ldots, m\}$ of length
$m$ iff $n \leq m \land s_i = p_i, i \in \{1, \ldots, n - 1\} \land s_n \neq
p_n$. In other words, $s$ is a subprefix of $p$ iff $s$ is no longer than $p$
and the bitwise XOR of $s$ and an appropriately truncated $p$ takes the form
$00\ldots001$. Each peer therefore has $m$ different subprefixes, one each of
every length in $\{1, \ldots, m\}$.

A peer has complete subprefix coverage iff for each of his subprefixes he knows
at least one query peer for whose ID that subprefix is a prefix. No matter what
target ID he wishes to query for, he always knows a query peer closer to it: He
simply selects the query peer corresponding to the subprefix that has the
largest overlap with the target ID. That peer is at least one bit closer, namely
the last bit of the subprefix that is different for the peer sending the query.

Moreover, there is a 50\% chance that the query peer's routing prefix overlaps
by at least 2 bits (in general, a $\frac{1}{n}$ chance it overlaps by at least
$n$ bits), just by luck. This means steps in the routing can be "skipped", an
authoritative peer for the target ID is reached sooner.

- TODO make or steal a tree graphic visualizing this

\subsection{Reputation Management}
\label{sec:desc_rep_management}
Penalty delays can only be correctly applied if every peer in a query group is
aware of all of his query peer's reputations. To achieve this, every peer stores
all relevant reputations locally, and receives updates for them from query peers
in the same query group.

The reputation of a query peer is initialized to 0 upon his joining the group.
It is subsequently modified through \emph{reputation updates} shared in the
group. A reputation update can either contain a reward, increasing the
reputation of the peer whom it is regarding, or a penalty, decreasing it.

Rewards and penalties are awarded in response to an interaction with another
peer or peers. In case the two peers share more than one query group, they are
applied in all of those groups (letting the peer choose in which group he would
like to receive the reputation update is open to abuse: he could choose to
receive a penalty in a group he doesn't really care about).

Rewards and penalties are handled in different ways for incentive reasons
(Section~\ref{sec:desc_rationale} goes into more detail on peer incentives).
After a peer performs a cooperative action (one deserving a reward, e.g.
successfully responding to a query) on another peer, the other peer sends him a
\emph{cooperation confirmation}, which is a statement signed by the other peer
confirming that the peer performed the action. The peer then broadcasts this
statement to all peers in the query group, who then increase the reputation they
have stored for the peer by the amount the rules of the system dictate should be
awarded for the action.

After a peer performs a defecting action on another peer, it is the other peer
that broadcasts the message stating what the first peer did. The query peers
again update their reputation record. For penalties, the peer who was wronged
must broadcast the message, since the one about to receive a penalty clearly has
no incentive to do it himself. Strictly speaking, the other peer doesn't either,
since there is no immediate benefit for him doing so (peers are selfish, not
vengeful). So broadcasting the reputation update must also give the broadcaster
a (small) reward.

The reputations stored at the members of a query group of course can't be
perfectly synchronized due to network delays. So whenever a peer has to make a
decision that depends on another peer's or his own reputation, he must give some
leeway to account for this. He should accept any action of another peer's as
appropriate that is within the rules according to any of the reputation values
in the recent past.

Reputation updates must include a timestamp at which they should be applied in
order to correct for different arrival orders. Otherwise, the reputation record
may diverge at different peers if they receive 2 updates in a different order,
where one of them set the reputation to 0. Consider a peer with 1 reputation and
2 updates arrive: one subtracting 2, the next adding 1. Subtracting first yields
1 reputation, adding first yields 0. In case 2 updates specify the same time,
use the uint value of the ID of the peer who sent the update (this implies that
peers must not send two reputation updates with the same timestamp).

The complete reputation record must be made available to a new peer joining a
query group. It is simply copied from the \emph{entry peer}, the one who handles
the joining of the new member. But this opens up the possibility for a race
condition if the new peer joins right after a current member of the group sends
a reputation update. The new peer will not be sent the update, but the update
may not have arrived in time at the entry peer for him to give a current copy to
the new member.

To address this, every peer must include a sequence number with every reputation
update he sends within a query group. This number is incremented by 1 with every
update he sends. Every peer maintains the last sequence number received by every
peer in the group. When joining a query group, the new peer receives a copy of
the current group state from one of the peers, which includes the sequence
numbers. Then, after he is established in the group, the new peer can check with
another peer whether he is up to date by giving his current state of sequence
numbers, potentially receiving a correction. To incentivize another peer's
cooperation in this, a reward is applied, but only once per new peer.

\section{Rationale}
\label{sec:desc_rationale}
The goal of the system that was described is to exploit the peers' desire to use
the DHT in order to get them to contribute, thereby cultivating the wide variety
of peers to choose from. To achieve this, every action the system requires the
peers to do must have an incentive, i.e. not carrying out the action must carry
the threat of being less likely to use the system with a good quality of
service.

It should be considered, though, that just because an action is rewarded, there
is no guarantee that it will be carried out. If a peer considers his current
amount of reputation sufficient, he may opt to not carry out such an action. In
that case, the peer is said to be \emph{reputation saturated}.

This notion of a hard cutoff is actually a simplified view on a selfish peer's
motivation. In a more realistic setting, whether a peer carries out an action
that is rewarded depends on the magnitude of the reward and the cost of the
action, which he weighs against one another. Peers would only perform an action
iff the value of the added reputation exceeds the cost of performing the action.

In the simplification in the implementation, peers always aim to be cooperative
right until they reach their saturation reputation, which is determined by the
penalty threshold and the reputation buffer described in (see
Section~\ref{sec:impl_coop_defect_behavior}). This acts as a proxy for their
weighing cost of action agains value of reputation.

\subsection{The Reputation System}
\label{sec:desc_rep_system}
This is the purpose of the reputation system. Without reputation, peers only
receive a poor level of service in the form of artificial delays. Looking up
someone's reachability information is assumed to be done right before initiating
communication with the other party. Artificial delays in this situation would be
annoying to the user and are therefore a good incentive for peers to gain
reputation.

Rewards and penalties can then be used to incentivize desirable and
disincentivize undesirable behavior. Rewards are applied for properly responding
to a query, i.e. within the right time frame, and with the correct record.
Penalties are applied for not responding at all, responding too early or too
late, or not being able to resolve the target ID to the correct record.

Of course, late queries must be penalized in order to keep up the promise
of good service for high reputation. But, a little less intuitively, early
queries must also be penalized. Without any incentive to apply the correct
penalty delay, peers would be inclined to respond at the next convenient time.
In many cases, that might be right away, so that the peer doesn't have to keep
the state of the interaction stored for longer than necessary. Delaying the
response also requires the programmer of the implementation to do extra work.
The peer might conceivably also just respond whenever network resources are
free.

The problem with being indifferent to peers responding with no delay at all is
that it reduces or removes the threat of not participating. If there are
generous peers responding without delay independent of reputation, there is less
of no incentive to gain reputation. If the system's goal was availability alone,
this may be fine, but it is also supposed to offer peers a wide variety of peers
as query targets to choose from, so that profile building becomes more
challenging. Reducing the incentive to gain reputation, and thereby to respond
to queries, hinders this. The generous peers would attract a lot of queries and
have it easier to build profiles, counteracting one of the goals of the system.

\subsection{Query Groups}
Reputation gained by responding to one peer entitles a peer to better service
from other peers. This makes sense, since one of the goals of the system is to
allow peers to spread their queries to many peers. It has to be practical for
any pair of peers to have very few interactions but still use the reputation
system. Having every peer keep a local reputation for his communication partners
is therefore not an option, as many peers wouldn't be able to gain sufficient
reputation over these few interactions to be entitled to a reasonable quality of
service.

Tracking reputation globally doesn't scale to large networks. Peers can't
practically store every other peer's reputation locally and receive updates for
all of them. Moreover, spreading these updates throughout the network to so many
recipients would be challenging and require incentives. Storing reputation in a
decentralized structure like the \ac{DHT} the system is supporting, or a wholly
separate one, would add additional delays. Before responding, each peer would
have to do a \ac{DHT} lookup to even determine when to send the response. This
would have to happen at every hop in the query. Not to mention that this
potentially includes another \ac{DHT}, the maintenance of which requires
incentives itself.

The solution offered in this thesis are query groups, which are small enough
that each peer can store locally the reputations of the query peers, and updates
can be broadcast. At the same time, peers don't have to cultivate a trusting
relationship with a peer before they can query him, only with the query group as
a whole. Query groups become the unit in which peers build trust in each other's
willingness to cooperate.

This of course segments the network into many small groups, and the ideal goal
of being able to query any other peer is not reached. But peers wishing for more
privacy can join more query groups than is necessary to complete their subprefix
coverage, thereby increasing the pool of query peers. Of course, this comes at a
higher management cost.

Furthermore, query groups can be changed frequently, so that peers in them don't
become so familiar with one's querying habits that they can build a meaningful
profile. Before leaving an old group, it makes sense to join a replacement group
and gain reputation above the penalty threshold to ensure a smooth transition.
Doing so more frequently again adds cost at the benefit of higher privacy.

\subsection{Incentives for Repuation Management}
\label{sec:desc_incentives_rep_mgmt}
There must also be incentives for reputation updates. After receiving a
successful response to a query, the querying peer sends a cooperation
confirmation to the responder which entitles him to his reward. He then
broadcasts a reputation update benefitting himself. The incentive for this is
evident.

Broadcasting a penalty for another peer also has to give a small reward to the
one sending it, as otherwise there would be no incentive to do so. This is the
case even if the penalty is applied for defecting on the sender of the penalty,
like failing to respond in time, since we're only assuming peers are selfish,
not vengeful. They do not consider hurting someone who hurt them a benefit.

For this to work, however, the complaint system is crucial. If the querying peer
doesn't send the cooperation confirmation, and there is no recourse and no
threat of penalty for it, selfish peers will not do it. Similarly, it must not
be possible to apply penalties to other peers without cause, just for the
benefit of the reward broadcasting it brings.

The complaint system is sadly out of scope for this thesis, and likely to have
to deal with complex dynamics arising from the interaction of peers. If it
doesn't work, the entire system doesn't work.

Reputation should not be so plentiful that all peers in a query group can become
reputation saturated. If that should happen, no one has any incentive to respond
to queries, but no one has an incentive to broadcast penalties anymore, either.
Everyone would remain at their current, saturated reputation without any work
actually getting done. Section~\ref{sec:attenuation} describes how to adjust the
parameters of \emph{reputation attenuation} in order to control how often peers
become saturated.

A possible modification to defuse the situation should it happen anyway is to
let reputation decay at a slow rate. At a set interval, a fixed amount of
reputation is subtracted from each peer in every query group. This can be
implemented without actual reputation updates by viewing reputation relative to
the group's creation time: Every time a peer accesses a query peer's reputation,
he subtracts a fraction of the group's age from the value stored in the
reputation record. This requires reasonably well-synchronized clocks.
\emph{Reputation decay} was implemented in the simulation as the first approach
to keep peers interested in participating, but the threat of penalty for failing
to respond turned out to be enough.

Besides broadcasting reputation updates, peers receiving them also need to have
an incentive to update their local reputation record. After all, simply ignoring
an incoming message is easier than processing it. The incentive is indirect and
results from the fact that peers need to know the accurate reputation of their
query peers in order to apply the correct penalty delays and thus avoid
penalties.

\subsection{Incentives in Sync Groups}
\label{sec:desc_incentives_sync}
Incentives are also needed in sync groups, where peers stay up to date with the
records they're responsible for. Updates to records are broadcast by the owner
of the record (since every peer stores exactly one record under his own ID, sync
groups consist of the owners of the records the group is responsible for). The
to do so is simply that other peers can reach him.

But there also needs to be an incentive to even listen to and apply updates
within the sync group; it would be easier to just dismiss them and respond with
the old record when queried, or even claim that, no matter the target ID, no
record exists for it.

The incentive here is indirect: If a peer responds with an outdated record or
claims no record exists even though it does, the querying peer may apply a
penalty for an incorrect response if he notices. This is not guaranteed to
happen, since it requires the querying peer to send at least one redundant
query. It does not require the complaint system, though: The querying peer has
the (signed) response containing incorrect information, and a response from
another peer with the correct information (records themselves are signed by the
owner, so can't be forged), and can therefore prove the defecting behavior.

The penalty is not guaranteed to be applied for another reason: Even if the
querying peer sends a second query, the other responder may also give an
incorrect response. In the extreme case, all members of a sync group respond "no
such record" to every query and no one can ever receive a penalty for an
incorrect query. This would be an equilibrium for this particular part of the
system, but an unfortunate one, since none of the records of the peers in the
sync group ever make their way to an outside peer.

But if even one peer properly applies the updates, there is a threat of penalty:
There is a chance the querying peer sends a second query, and again a chance
that the response comes from one such peer. Then the querying peer will apply a
penalty. Depending on a peer's current reputation and the magnitude of the
penalty, this can seem like an acceptable risk. The penalty should therefore be
set sufficiently high to ensure that it does so rarely. If that is the case,
peers need to apply updates in order to even be able to respond correctly when
they are low on reputation. If they have the current information anyway when a
query arrives, the cost of responding correctly (looking up the record in
memory) shouldn't be much higher than just responding "no such record".

\subsection{Relative Amounts of Rewards and Penalties}
While not tested in experiment, some general rules for the relative proportion
of different rewards and penalties are apparent.

The penalty for letting a query time out should be greater than that for a fail
response (one which states the target ID couldn't be resolved). The latter is
more useful to the querying peer, since it takes less time and allows him to
e.g. send a retry sooner.

The reward for broadcasting a penalty should probably be less than any penalty,
otherwise it becomes easy for colluding peers to "penalize" each other, thus
gaining arbitrary reputation. Technically, the complaint system is supposed to
catch this, and there are considerations on how to limit collusion in
Section~\ref{sec:desc_collusion_sybil_attacks}, but it seems ill-advised to make
this kind of behavior possible in the first place.

The penalty for an incorrect response should be set sufficiently high to
disincentivize them even if the likelihood of actually receiving the penalty is
low (see Section~\ref{sec:desc_incentives_sync}).

\subsection{The Recursive Query Problem}
\label{sec:desc_rec_query_prob}
Recursive queries can lead to the \emph{recursive query problem}, which is a
peer's bad reputation in one query group having adverse effects on his
reputation in another. Say peer A receives a query from peer B, and they share
query group X. A needs to send the query on to one of his query peers in order
to answer it, and determines that peer C is the most suitable recipient, whom he
knows from query group Y. A is expected to respond to B within a time window
determined by B's reputation in group X. Similarly, C is expected to respond to
A within a time window determined by A's reputation in group Y. If minimum delay
of the latter time window is greater than the maximum delay of the former, A has
no chance of responding in time (that is assuming C observes the expected delay)
and will be penalized for it.

- TODO make a graphic for the recursive query problem

Under these circumstances, A's bad reputation in group Y leads to a penalty in
group X. This is potentially a serious hindrance to a peer's ability to gain
reputation. Under unfortunate circumstances, one could imagine low reputation
values in two query groups keeping each other down. This problem can also be
observed in the simulation results, see
Section~\ref{sec:rep_avail_rec_query_prob}.

While the recursive query problem can impede peers' ability to gain reputation,
there is an argument that it can be a good thing once peers have sufficient
reputation. It forces them to maintain good subprefix coverage with a good
quality of service, even if they may not care about parts of the ID namespace
personally.

\subsection{Empty Sync Groups}
\label{sec:desc_empty_sync_groups}
There may be a routing prefix for which there is no peer, i.e. the corresponding
sync group is empty. In that case, there is no one who can authoritatively
answer queries for this prefix (stating that no peer exists). Such queries are
still legitimate, e.g. because there used to be a peer with the routing prefix
in question. But more importantly, they occur when the empty routing prefix is
the subprefix of some peer. That peer will send a prefix query to complete his
subprefix coverage but never receive an authoritative response. Peers close to
the empty sync group (sync peers of the peer, whose routing prefix is equal to
the empty one except in the final bit) could respond that there probably doesn't
exist a peer, but this isn't ideal.

The only workaround that can be offered is to choose the routing prefix length
in such a way that empty sync groups don't occur. It must be variable during
operation anyway, in order to support changes in network size. This can be
achieved e.g. through a system like the one described in
Section~\ref{sec:desc_load_balancing}, but maybe also a simpler one, in which
the routing prefix length is the same for all peers, but can be changed at
runtime.

Besides empty sync groups, groups with only very few peers cause problems as
well, as they make peers' ability to gain reputation brittle, as described in
Section~\ref{sec:rep_avail_small_sync_groups}.

\subsection{Circular Queries}
There is nothing in the system in principle that prevents peers from querying a
peer who is not closer to the target ID than they are themselves. If they do,
circular queries, or routing loops, can occur, in which peer A queries peer B,
who queries peer C, who queries peer A again. Without any way of detecting such
loops, peer A may even think that he can use the response to his initial query
to answer the query he received from C, and not query anyone else. Then all
queries will time out and everyone (including peer A) receive a penalty, even if
all involved were trying to cooperate.

There are no incentives specifically in place to get peers to only query peers
closer to the target ID. Usually of course, it is better for a peer to query the
closest peer since that reduces the number of hops required and thus the
response time. But if the peer has low reputation in all the query groups he
shares with peers closer to the target ID, it is the rational choice to instead
query one who is not closer from a group in which he has high reputation. The
absence of the penalty delay is likely to make up for the additional hops.

Forbidding such queries entirely isn't an option either, since they are
sometimes necessary. In particular for new peers looking to complete their
subprefix coverage. They have to query peers not closer to the subprefix they're
querying for, since they don't know anyone closer (that's why they're doing it,
after all). It might be an option to respond to such queries, but give a large
penalty for posing them. That wouldn't affect new peers, who have no reputation
yet anyway, while disincentivizing the behavior for established peers.
