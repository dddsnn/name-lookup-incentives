\chapter{System Description}
\section{Goal}
- if everyone is selfish but wants to have access to lots of peers, get them to
  contribute
- effective and without negative impacts for cooperating peers
- 4 major areas of interest: reputation availability, mitigating selfishness,
  query group maintenance dynamics, complaints
- prevent freeriding, can't trust peers initially (rep must start at 0)
- resistant to whitewashing

\section{Organization}
- kademlia/p-grid-style dht
- sync groups for replication/syncing, query groups for descending into the tree
- sync groups maintain records and send each other updates (broadcast here,
  possibly gossipping)
- reputation score is maintained in query groups (each peer stores every
  member's reputation
- peers get reputation for answering queries, penalties for failing to do so (or
  doing so late/early)
- credit-only system
- above a threshold, they get delay-free service
- below that, responses to them are delayed
- peers want delay-free service, so they have to participate
- decay, is necessary to prevent peers from getting rep and then not offering
  any prefixes anymore (thus not receiving penalties), but that didn't go well
  (also into reputation availability chapter)
- reputation attenuation
- reputation update incentives, here assumed not necessary
- too early responses must also be penalized
- query group formation out of scope
- complaint system if someone misbehaves in non-public interaction, out of scope
- peers can send multiple queries to minimize the risk of a timeout
- peers must send a query to the lowest-reputation peer, but may send more to
  others
- recursive queries vs. iterative queries w/ vouchers vs. explicitly promising
  response times w/ advertised prefixes
- there needs to be some leeway given, as reputation etc. aren't perfectly
  synchronized
- peers can specify which peers they don't want as a response
  (excluded\_peer\_ids)
\subsection{Definitions}
- ID
- prefix
- subprefix
- subprefix coverage
- target ID (the thing that's queried for, can be a full ID or just a prefix)
- being "closer to" an ID, overlap
- hop
- reputation
- reward, penalty
- no-penalty reputation
- authoritative sync group (necessary?); only sync group can answer query with
  authority (they are the only ones assumed to have current data)
- record
- good performance, i.e. being able to get reputation quickly
- recursive query problem
- find a term for "minimum reputation in all shared query groups" used e.g. in
  peer selection
- routing loop
- a peer being "useful" in a query group, i.e. others
- game theory stuff: utility, cooperating, defecting, social value (probably
  more)
- "serving a prefix"
- content peer, one who is content with the lowest level of service (e.g.
  because of low-power device)
\subsection{Reputation Management}
==============
- TODO this is from some notes i took earlier. incorporate them
Reputation updates must include the time at which they should be applied in
order to correct for different transmission delays. Otherwise, the reputation
record may diverge at different peers if they receive 2 updates in a different
order, where one of them set the reputation to 0. (E.g. a peer has 1 reputation
and 2 updates arrive one subtracting 2, the next adding 1. Subtracting first
yields 1 reputation, adding first yields 0.) In case 2 updates specify the same
time, a deterministic tie breaker must exist (e.g. uint value of the peer ID).

There must be some leeway when checking the reputation in a peer, since updates
that should have taken effect already may still be in transmission. This needs
to be taken into account when deciding on the penalty delay, but also when
deciding whether a peer is misbehaving (e.g. answering too early).

Every peer must include a sequence number with every reputation update he sends
within a query group. This number must be incremented by 1 with every update
(TODO why exactly 1, why not just at least 1?).
Every peer must maintain the last sequence number received by every peer in a
query group (vector clock). When joining a query group, the new peer must
receive a copy of the current group state from one of the peers which includes
the state of the vector clock. This is necessary to allow the new peer to detect
whether he has missed an update that was sent when he wasn't in the group yet.
E.g. consider a query group containing peers A and B. A sends a reputation
update. Before it arrives at B, peer C joins the group and receives a copy of
the group state from B. Since C wasn't in the group when A sent its update, A
didn't send the update to C, and B didn't know about the update when it sent the
copy of the group state to C, so C still has the state from before the update. C
must then ask all peers in the group whether it missed any updates. For this, he
needs to include the sequence number, otherwise it's impossible to say with
certainty which updates are already included in the state C received from B.
This system is also necessary if updates are done via gossiping (TODO why?).
=============

- rewards/penalties are applied in all query groups shared by the 2 peers
  involved (the one giving and the one receiving the reward/penalty). it would
  be possible to let the would-be receiver of a reward/penalty decide in which
  query group he wants to receive it, but that seems complicated (and is
  potentially open to abuse, letting a peer specify to be penalized in a group
  he doesn't care about)
- when a query has been successfully answered, the recipient gives a reward by
  sending a signed statement to the sender that says the sender should be given
  a reward; the sender then has an incentive to broadcast this. if the recipient
  fails to send that statement, the complaint mechanism is needed
- penalties are broadcast by the recipient (of a failed query, or the peer who
  experienced a timeout). the incentive for this must be a (small) reward for
  broadcasting it. this is of course open to abuse and requires the complaint
  mechanism again
\subsection{Query Group Creation and Maintenance}
\subsection{Complaints}
- used for situations in which two peers disagree about something, one is lying,
  but no other than the two know the truth

\section{Peers}
\subsection{Simplifying Assumptions}
- don't lie about time stamps
- always broadcast reputation updates truthfully, even without incentive; reward
  updates are broadcast by the peer giving the reward, not the one receiving it
- there is no reward for broadcasting penalties
- are not actively malicious
- all records are equally likely to be queried. would not hold in a real system,
  you'd need load-balancing: self-organizing with incentives, so you need the
  p-grid approach of being able to advertise more prefixes
\subsection{Types}
- cooperating (should refusing to answer count towards this, as the system
  calculates with peers being selfish?)
- defecting out of laziness
- sabotaging, i.e. investing resources to ruin it for others
- not contributing because satisfied with minimal service, e.g. slow embedded
  stuff (content peer, see definitions)
- vengeful? i.e. sabotaging after another peer didn't collude?

\section{Possible Attacks}
- distinguish attacks on the reputation system (getting more/disrupting it) vs.
  attacks on privacy, subverting the design goal of being hard to track (the
  latter isn't the primary focus, but should be kept in mind)
- collusion: peers can only give rewards to any other given peer every so often
  (timer counting down). requires keeping a lot more state, also not at all
  clear about the consequences: what if you need to query, but none of the
  possible recipients are interested in answering because you can't reward them?
  you'd need more query peers for shorter subprefixes (that's actually what
  kademlia does for performance)


- something must be done to prevent circular queries: a queries b, b queries c,
  c queries a again, and a awaits the answer from b in order to answer. this is
  a problem when finding missing subprefix coverage (it's not a problem if peers
  only query other peers whose overlap is strictly greater)
- assume all sync groups have peers (you can't respond "doesn't exist" for a
  query for an ID in a sync group you're not in. it may be possible to respond
  "probably doesn't exist, with some proof how much work you did, but that's out
  of scope
- reputation updates require a vector clock so that a peer who has just joined a
  group can detect whether he has missed an update that was sent before the
  sender knew the new peer needed to receive it as well (see notes.md)
- incentives to keep up-to-date in sync groups: indirect, huge penalty for
  providing outdated records
